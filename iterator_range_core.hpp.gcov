        -:    0:Source:/usr/include/boost/range/iterator_range_core.hpp
        -:    0:Programs:1
        -:    1:// Boost.Range library
        -:    2://
        -:    3://  Copyright Neil Groves & Thorsten Ottosen & Pavol Droba 2003-2004.
        -:    4://  Use, modification and distribution is subject to the Boost Software
        -:    5://  License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
        -:    6://  http://www.boost.org/LICENSE_1_0.txt)
        -:    7://
        -:    8:// For more information, see http://www.boost.org/libs/range/
        -:    9://
        -:   10:#ifndef BOOST_RANGE_ITERATOR_RANGE_CORE_HPP_INCLUDED
        -:   11:#define BOOST_RANGE_ITERATOR_RANGE_CORE_HPP_INCLUDED
        -:   12:
        -:   13:#include <boost/config.hpp> // Define __STL_CONFIG_H, if appropriate.
        -:   14:#include <boost/detail/workaround.hpp>
        -:   15:
        -:   16:#if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1500))
        -:   17:    #pragma warning( push )
        -:   18:    #pragma warning( disable : 4996 )
        -:   19:#endif
        -:   20:
        -:   21:#include <boost/assert.hpp>
        -:   22:#include <boost/iterator/iterator_traits.hpp>
        -:   23:#include <boost/iterator/iterator_facade.hpp>
        -:   24:#include <boost/type_traits/is_abstract.hpp>
        -:   25:#include <boost/type_traits/is_pointer.hpp>
        -:   26:#include <boost/range/functions.hpp>
        -:   27:#include <boost/range/iterator.hpp>
        -:   28:#include <boost/range/difference_type.hpp>
        -:   29:#include <boost/range/algorithm/equal.hpp>
        -:   30:#include <boost/range/detail/safe_bool.hpp>
        -:   31:#include <boost/utility/enable_if.hpp>
        -:   32:#include <iterator>
        -:   33:#include <algorithm>
        -:   34:#include <cstddef>
        -:   35:
        -:   36:/*! \file
        -:   37:    Defines the \c iterator_class and related functions.
        -:   38:    \c iterator_range is a simple wrapper of iterator pair idiom. It provides
        -:   39:    a rich subset of Container interface.
        -:   40:*/
        -:   41:
        -:   42:
        -:   43:namespace boost
        -:   44:{
        -:   45:    namespace iterator_range_detail
        -:   46:    {
        -:   47:        //
        -:   48:        // The functions adl_begin and adl_end are implemented in a separate
        -:   49:        // class for gcc-2.9x
        -:   50:        //
        -:   51:        template<class IteratorT>
        -:   52:        struct iterator_range_impl {
        -:   53:            template< class ForwardRange >
        -:   54:            static IteratorT adl_begin( ForwardRange& r )
        -:   55:            {
        -:   56:                return IteratorT( boost::begin( r ) );
        -:   57:            }
        -:   58:
        -:   59:            template< class ForwardRange >
        -:   60:            static IteratorT adl_end( ForwardRange& r )
        -:   61:            {
        -:   62:                return IteratorT( boost::end( r ) );
        -:   63:            }
        -:   64:        };
        -:   65:
        -:   66:        template< class Left, class Right >
        -:   67:        inline bool less_than( const Left& l, const Right& r )
        -:   68:        {
        -:   69:            return std::lexicographical_compare( boost::begin(l),
        -:   70:                                                 boost::end(l),
        -:   71:                                                 boost::begin(r),
        -:   72:                                                 boost::end(r) );
        -:   73:        }
        -:   74:
        -:   75:        // This version is maintained since it is used in other boost libraries
        -:   76:        // such as Boost.Assign
        -:   77:        template< class Left, class Right >
        -:   78:        inline bool equal(const Left& l, const Right& r)
        -:   79:        {
        -:   80:            return boost::equal(l, r);
        -:   81:        }
        -:   82:
        -:   83:        struct range_tag { };
        -:   84:        struct const_range_tag { };
        -:   85:    }
        -:   86:
        -:   87://  iterator range template class -----------------------------------------//
        -:   88:
        -:   89:        //! iterator_range class
        -:   90:        /*!
        -:   91:            An \c iterator_range delimits a range in a sequence by beginning and ending iterators.
        -:   92:            An iterator_range can be passed to an algorithm which requires a sequence as an input.
        -:   93:            For example, the \c toupper() function may be used most frequently on strings,
        -:   94:            but can also be used on iterator_ranges:
        -:   95:
        -:   96:            \code
        -:   97:                boost::tolower( find( s, "UPPERCASE STRING" ) );
        -:   98:            \endcode
        -:   99:
        -:  100:            Many algorithms working with sequences take a pair of iterators,
        -:  101:            delimiting a working range, as an arguments. The \c iterator_range class is an
        -:  102:            encapsulation of a range identified by a pair of iterators.
        -:  103:            It provides a collection interface,
        -:  104:            so it is possible to pass an instance to an algorithm requiring a collection as an input.
        -:  105:        */
        -:  106:        template<class IteratorT>
        -:  107:        class iterator_range
        -:  108:        {
        -:  109:            typedef range_detail::safe_bool< IteratorT iterator_range<IteratorT>::* > safe_bool_t;
        -:  110:        protected: // Used by sub_range
        -:  111:            //! implementation class
        -:  112:            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;
        -:  113:        public:
        -:  114:            //! this type
        -:  115:            typedef iterator_range<IteratorT> type;
        -:  116:            typedef BOOST_DEDUCED_TYPENAME safe_bool_t::unspecified_bool_type unspecified_bool_type;
        -:  117:            //BOOST_BROKEN_COMPILER_TYPE_TRAITS_SPECIALIZATION(value_type);
        -:  118:
        -:  119:            //! Encapsulated value type
        -:  120:            typedef BOOST_DEDUCED_TYPENAME
        -:  121:                iterator_value<IteratorT>::type value_type;
        -:  122:
        -:  123:            //! Difference type
        -:  124:            typedef BOOST_DEDUCED_TYPENAME
        -:  125:                iterator_difference<IteratorT>::type difference_type;
        -:  126:
        -:  127:            //! Size type
        -:  128:            typedef std::size_t size_type; // note: must be unsigned
        -:  129:
        -:  130:            //! This type
        -:  131:            typedef iterator_range<IteratorT> this_type;
        -:  132:
        -:  133:            //! Reference type
        -:  134:            //
        -:  135:            // Needed because value-type is the same for
        -:  136:            // const and non-const iterators
        -:  137:            //
        -:  138:            typedef BOOST_DEDUCED_TYPENAME
        -:  139:                iterator_reference<IteratorT>::type reference;
        -:  140:
        -:  141:            //! const_iterator type
        -:  142:            /*!
        -:  143:                There is no distinction between const_iterator and iterator.
        -:  144:                These typedefs are provides to fulfill container interface
        -:  145:            */
        -:  146:            typedef IteratorT const_iterator;
        -:  147:            //! iterator type
        -:  148:            typedef IteratorT iterator;
        -:  149:
        -:  150:        private: // for return value of operator()()
        -:  151:            typedef BOOST_DEDUCED_TYPENAME
        -:  152:                boost::mpl::if_< boost::is_abstract<value_type>,
        -:  153:                                 reference, value_type >::type abstract_value_type;
        -:  154:
        -:  155:        public:
        -:  156:            iterator_range() : m_Begin( iterator() ), m_End( iterator() )
        -:  157:            { }
        -:  158:
        -:  159:            //! Constructor from a pair of iterators
        -:  160:            template< class Iterator >
function _ZN5boost14iterator_rangeINS_12range_detail16integer_iteratorImEEEC2IS3_EET_S6_ called 60392 returned 100% blocks executed 100%
    60392:  161:            iterator_range( Iterator Begin, Iterator End ) :
    60392:  162:                m_Begin(Begin), m_End(End)
    60392:  163:            {}
        -:  164:
        -:  165:            //! Constructor from a Range
        -:  166:            template< class Range >
        -:  167:            iterator_range( const Range& r ) :
        -:  168:                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
        -:  169:            {}
        -:  170:
        -:  171:            //! Constructor from a Range
        -:  172:            template< class Range >
        -:  173:            iterator_range( Range& r ) :
        -:  174:                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
        -:  175:            {}
        -:  176:
        -:  177:            //! Constructor from a Range
        -:  178:            template< class Range >
        -:  179:            iterator_range( const Range& r, iterator_range_detail::const_range_tag ) :
        -:  180:                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
        -:  181:            {}
        -:  182:
        -:  183:            //! Constructor from a Range
        -:  184:            template< class Range >
        -:  185:            iterator_range( Range& r, iterator_range_detail::range_tag ) :
        -:  186:                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
        -:  187:            {}
        -:  188:
        -:  189:            #if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
        -:  190:            this_type& operator=( const this_type& r )
        -:  191:            {
        -:  192:                m_Begin  = r.begin();
        -:  193:                m_End    = r.end();
        -:  194:                return *this;
        -:  195:            }
        -:  196:            #endif
        -:  197:
        -:  198:            template< class Iterator >
        -:  199:            iterator_range& operator=( const iterator_range<Iterator>& r )
        -:  200:            {
        -:  201:                m_Begin  = r.begin();
        -:  202:                m_End    = r.end();
        -:  203:                return *this;
        -:  204:            }
        -:  205:
        -:  206:            template< class ForwardRange >
        -:  207:            iterator_range& operator=( ForwardRange& r )
        -:  208:            {
        -:  209:                m_Begin  = impl::adl_begin( r );
        -:  210:                m_End    = impl::adl_end( r );
        -:  211:                return *this;
        -:  212:            }
        -:  213:
        -:  214:            template< class ForwardRange >
        -:  215:            iterator_range& operator=( const ForwardRange& r )
        -:  216:            {
        -:  217:                m_Begin  = impl::adl_begin( r );
        -:  218:                m_End    = impl::adl_end( r );
        -:  219:                return *this;
        -:  220:            }
        -:  221:
function _ZNK5boost14iterator_rangeINS_12range_detail16integer_iteratorImEEE5beginEv called 72 returned 100% blocks executed 100%
       72:  222:            IteratorT begin() const
        -:  223:            {
       72:  224:                return m_Begin;
        -:  225:            }
        -:  226:
function _ZNK5boost14iterator_rangeINS_12range_detail16integer_iteratorImEEE3endEv called 72 returned 100% blocks executed 100%
       72:  227:            IteratorT end() const
        -:  228:            {
       72:  229:                return m_End;
        -:  230:            }
        -:  231:
function _ZNK5boost14iterator_rangeINS_12range_detail16integer_iteratorImEEE4sizeEv called 60248 returned 100% blocks executed 100%
    60248:  232:            difference_type size() const
        -:  233:            {
    60248:  234:				return m_End - m_Begin;
call    0 returned 100%
        -:  235:            }
        -:  236:
        -:  237:            bool empty() const
        -:  238:            {
        -:  239:                return m_Begin == m_End;
        -:  240:            }
        -:  241:
        -:  242:            operator unspecified_bool_type() const
        -:  243:            {
        -:  244:                return safe_bool_t::to_unspecified_bool(m_Begin != m_End, &iterator_range::m_Begin);
        -:  245:            }
        -:  246:
        -:  247:            bool operator!() const
        -:  248:            {
        -:  249:                return empty();
        -:  250:            }
        -:  251:
        -:  252:            bool equal( const iterator_range& r ) const
        -:  253:            {
        -:  254:                return m_Begin == r.m_Begin && m_End == r.m_End;
        -:  255:            }
        -:  256:
        -:  257:
        -:  258:#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  259:
        -:  260:            bool operator==( const iterator_range& r ) const
        -:  261:            {
        -:  262:                return boost::equal( *this, r );
        -:  263:            }
        -:  264:
        -:  265:            bool operator!=( const iterator_range& r ) const
        -:  266:            {
        -:  267:                return !operator==(r);
        -:  268:            }
        -:  269:
        -:  270:           bool operator<( const iterator_range& r ) const
        -:  271:           {
        -:  272:               return iterator_range_detail::less_than( *this, r );
        -:  273:           }
        -:  274:
        -:  275:#endif
        -:  276:
        -:  277:        public: // convenience
        -:  278:           reference front() const
        -:  279:           {
        -:  280:               BOOST_ASSERT( !empty() );
        -:  281:               return *m_Begin;
        -:  282:           }
        -:  283:
        -:  284:           reference back() const
        -:  285:           {
        -:  286:               BOOST_ASSERT( !empty() );
        -:  287:               IteratorT last( m_End );
        -:  288:               return *--last;
        -:  289:           }
        -:  290:
        -:  291:           // pop_front() - added to model the SinglePassRangePrimitiveConcept
        -:  292:           void pop_front()
        -:  293:           {
        -:  294:               BOOST_ASSERT( !empty() );
        -:  295:               ++m_Begin;
        -:  296:           }
        -:  297:
        -:  298:           // pop_back() - added to model the BidirectionalRangePrimitiveConcept
        -:  299:           void pop_back()
        -:  300:           {
        -:  301:               BOOST_ASSERT( !empty() );
        -:  302:               --m_End;
        -:  303:           }
        -:  304:
        -:  305:           reference operator[]( difference_type at ) const
        -:  306:           {
        -:  307:               BOOST_ASSERT( at >= 0 && at < size() );
        -:  308:               return m_Begin[at];
        -:  309:           }
        -:  310:
        -:  311:           //
        -:  312:           // When storing transform iterators, operator[]()
        -:  313:           // fails because it returns by reference. Therefore
        -:  314:           // operator()() is provided for these cases.
        -:  315:           //
        -:  316:           abstract_value_type operator()( difference_type at ) const
        -:  317:           {
        -:  318:               BOOST_ASSERT( at >= 0 && at < size() );
        -:  319:               return m_Begin[at];
        -:  320:           }
        -:  321:
        -:  322:           iterator_range& advance_begin( difference_type n )
        -:  323:           {
        -:  324:               std::advance( m_Begin, n );
        -:  325:               return *this;
        -:  326:           }
        -:  327:
        -:  328:           iterator_range& advance_end( difference_type n )
        -:  329:           {
        -:  330:               std::advance( m_End, n );
        -:  331:               return *this;
        -:  332:           }
        -:  333:
        -:  334:        private:
        -:  335:            // begin and end iterators
        -:  336:            IteratorT m_Begin;
        -:  337:            IteratorT m_End;
        -:  338:
        -:  339:        protected:
        -:  340:            //
        -:  341:            // Allow subclasses an easy way to access the
        -:  342:            // base type
        -:  343:            //
        -:  344:            typedef iterator_range iterator_range_;
        -:  345:        };
        -:  346:
        -:  347://  iterator range free-standing operators ---------------------------//
        -:  348:
        -:  349:        /////////////////////////////////////////////////////////////////////
        -:  350:        // comparison operators
        -:  351:        /////////////////////////////////////////////////////////////////////
        -:  352:
        -:  353:        template< class IteratorT, class ForwardRange >
        -:  354:        inline bool operator==( const ForwardRange& l,
        -:  355:                                const iterator_range<IteratorT>& r )
        -:  356:        {
        -:  357:            return boost::equal( l, r );
        -:  358:        }
        -:  359:
        -:  360:        template< class IteratorT, class ForwardRange >
        -:  361:        inline bool operator!=( const ForwardRange& l,
        -:  362:                                const iterator_range<IteratorT>& r )
        -:  363:        {
        -:  364:            return !boost::equal( l, r );
        -:  365:        }
        -:  366:
        -:  367:        template< class IteratorT, class ForwardRange >
        -:  368:        inline bool operator<( const ForwardRange& l,
        -:  369:                               const iterator_range<IteratorT>& r )
        -:  370:        {
        -:  371:            return iterator_range_detail::less_than( l, r );
        -:  372:        }
        -:  373:
        -:  374:#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  375:#else
        -:  376:        template< class Iterator1T, class Iterator2T >
        -:  377:        inline bool operator==( const iterator_range<Iterator1T>& l,
        -:  378:                                const iterator_range<Iterator2T>& r )
        -:  379:        {
        -:  380:            return boost::equal( l, r );
        -:  381:        }
        -:  382:
        -:  383:        template< class IteratorT, class ForwardRange >
        -:  384:        inline bool operator==( const iterator_range<IteratorT>& l,
        -:  385:                                const ForwardRange& r )
        -:  386:        {
        -:  387:            return boost::equal( l, r );
        -:  388:        }
        -:  389:
        -:  390:
        -:  391:        template< class Iterator1T, class Iterator2T >
        -:  392:        inline bool operator!=( const iterator_range<Iterator1T>& l,
        -:  393:                                const iterator_range<Iterator2T>& r )
        -:  394:        {
        -:  395:            return !boost::equal( l, r );
        -:  396:        }
        -:  397:
        -:  398:        template< class IteratorT, class ForwardRange >
        -:  399:        inline bool operator!=( const iterator_range<IteratorT>& l,
        -:  400:                                const ForwardRange& r )
        -:  401:        {
        -:  402:            return !boost::equal( l, r );
        -:  403:        }
        -:  404:
        -:  405:
        -:  406:        template< class Iterator1T, class Iterator2T >
        -:  407:        inline bool operator<( const iterator_range<Iterator1T>& l,
        -:  408:                               const iterator_range<Iterator2T>& r )
        -:  409:        {
        -:  410:            return iterator_range_detail::less_than( l, r );
        -:  411:        }
        -:  412:
        -:  413:        template< class IteratorT, class ForwardRange >
        -:  414:        inline bool operator<( const iterator_range<IteratorT>& l,
        -:  415:                               const ForwardRange& r )
        -:  416:        {
        -:  417:            return iterator_range_detail::less_than( l, r );
        -:  418:        }
        -:  419:
        -:  420:#endif // BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  421:
        -:  422://  iterator range utilities -----------------------------------------//
        -:  423:
        -:  424:        //! iterator_range construct helper
        -:  425:        /*!
        -:  426:            Construct an \c iterator_range from a pair of iterators
        -:  427:
        -:  428:            \param Begin A begin iterator
        -:  429:            \param End An end iterator
        -:  430:            \return iterator_range object
        -:  431:        */
        -:  432:        template< typename IteratorT >
        -:  433:        inline iterator_range< IteratorT >
        -:  434:        make_iterator_range( IteratorT Begin, IteratorT End )
        -:  435:        {
        -:  436:            return iterator_range<IteratorT>( Begin, End );
        -:  437:        }
        -:  438:
        -:  439:#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  440:
        -:  441:        template< typename Range >
        -:  442:        inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<Range>::type >
        -:  443:        make_iterator_range( Range& r )
        -:  444:        {
        -:  445:            return iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<Range>::type >
        -:  446:                ( boost::begin( r ), boost::end( r ) );
        -:  447:        }
        -:  448:
        -:  449:#else
        -:  450:        //! iterator_range construct helper
        -:  451:        /*!
        -:  452:            Construct an \c iterator_range from a \c Range containing the begin
        -:  453:            and end iterators.
        -:  454:        */
        -:  455:        template< class ForwardRange >
        -:  456:        inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<ForwardRange>::type >
        -:  457:        make_iterator_range( ForwardRange& r )
        -:  458:        {
        -:  459:           return iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<ForwardRange>::type >
        -:  460:                ( r, iterator_range_detail::range_tag() );
        -:  461:        }
        -:  462:
        -:  463:        template< class ForwardRange >
        -:  464:        inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<const ForwardRange>::type >
        -:  465:        make_iterator_range( const ForwardRange& r )
        -:  466:        {
        -:  467:           return iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<const ForwardRange>::type >
        -:  468:                ( r, iterator_range_detail::const_range_tag() );
        -:  469:        }
        -:  470:
        -:  471:#endif // BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  472:
        -:  473:        namespace iterator_range_detail
        -:  474:        {
        -:  475:            template< class Range >
        -:  476:            inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<Range>::type >
        -:  477:            make_range_impl( Range& r,
        -:  478:                             BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_begin,
        -:  479:                             BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_end )
        -:  480:            {
        -:  481:                //
        -:  482:                // Not worth the effort
        -:  483:                //
        -:  484:                //if( advance_begin == 0 && advance_end == 0 )
        -:  485:                //    return make_iterator_range( r );
        -:  486:                //
        -:  487:
        -:  488:                BOOST_DEDUCED_TYPENAME range_iterator<Range>::type
        -:  489:                    new_begin = boost::begin( r ),
        -:  490:                    new_end   = boost::end( r );
        -:  491:                std::advance( new_begin, advance_begin );
        -:  492:                std::advance( new_end, advance_end );
        -:  493:                return make_iterator_range( new_begin, new_end );
        -:  494:            }
        -:  495:        }
        -:  496:
        -:  497:#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  498:
        -:  499:        template< class Range >
        -:  500:        inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<Range>::type >
        -:  501:        make_iterator_range( Range& r,
        -:  502:                    BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_begin,
        -:  503:                    BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_end )
        -:  504:        {
        -:  505:            //BOOST_ASSERT( advance_begin - advance_end <= size(r) && "creating invalid range" );
        -:  506:            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        -:  507:        }
        -:  508:
        -:  509:#else
        -:  510:
        -:  511:        template< class Range >
        -:  512:        inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<Range>::type >
        -:  513:        make_iterator_range( Range& r,
        -:  514:                    BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_begin,
        -:  515:                    BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_end )
        -:  516:        {
        -:  517:            //BOOST_ASSERT( advance_begin - advance_end <= size(r) && "creating invalid range" );
        -:  518:            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        -:  519:        }
        -:  520:
        -:  521:        template< class Range >
        -:  522:        inline iterator_range< BOOST_DEDUCED_TYPENAME range_iterator<const Range>::type >
        -:  523:        make_iterator_range( const Range& r,
        -:  524:                    BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_begin,
        -:  525:                    BOOST_DEDUCED_TYPENAME range_difference<Range>::type advance_end )
        -:  526:        {
        -:  527:            //BOOST_ASSERT( advance_begin - advance_end <= size(r) && "creating invalid range" );
        -:  528:            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        -:  529:        }
        -:  530:
        -:  531:#endif // BOOST_NO_FUNCTION_TEMPLATE_ORDERING
        -:  532:
        -:  533:        //! copy a range into a sequence
        -:  534:        /*!
        -:  535:            Construct a new sequence of the specified type from the elements
        -:  536:            in the given range
        -:  537:
        -:  538:            \param Range An input range
        -:  539:            \return New sequence
        -:  540:        */
        -:  541:        template< typename SeqT, typename Range >
        -:  542:        inline SeqT copy_range( const Range& r )
        -:  543:        {
        -:  544:            return SeqT( boost::begin( r ), boost::end( r ) );
        -:  545:        }
        -:  546:
        -:  547:} // namespace 'boost'
        -:  548:
        -:  549:#if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1500))
        -:  550:    #pragma warning( pop )
        -:  551:#endif
        -:  552:
        -:  553:#endif
        -:  554:
