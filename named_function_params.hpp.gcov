        -:    0:Source:/usr/include/boost/graph/named_function_params.hpp
        -:    0:Programs:1
        -:    1://=======================================================================
        -:    2:// Copyright 1997, 1998, 1999, 2000 University of Notre Dame.
        -:    3:// Authors: Andrew Lumsdaine, Lie-Quan Lee, Jeremy G. Siek
        -:    4://
        -:    5:// Distributed under the Boost Software License, Version 1.0. (See
        -:    6:// accompanying file LICENSE_1_0.txt or copy at
        -:    7:// http://www.boost.org/LICENSE_1_0.txt)
        -:    8://=======================================================================
        -:    9:
        -:   10:#ifndef BOOST_GRAPH_NAMED_FUNCTION_PARAMS_HPP
        -:   11:#define BOOST_GRAPH_NAMED_FUNCTION_PARAMS_HPP
        -:   12:
        -:   13:#include <functional>
        -:   14:#include <vector>
        -:   15:#include <boost/ref.hpp>
        -:   16:#include <boost/parameter/name.hpp>
        -:   17:#include <boost/parameter/binding.hpp>
        -:   18:#include <boost/type_traits/is_same.hpp>
        -:   19:#include <boost/mpl/not.hpp>
        -:   20:#include <boost/type_traits/add_reference.hpp>
        -:   21:#include <boost/graph/properties.hpp>
        -:   22:#include <boost/graph/detail/d_ary_heap.hpp>
        -:   23:#include <boost/property_map/property_map.hpp>
        -:   24:#include <boost/property_map/shared_array_property_map.hpp>
        -:   25:
        -:   26:namespace boost {
        -:   27:
        -:   28:  struct parity_map_t { };
        -:   29:  struct vertex_assignment_map_t { };
        -:   30:  struct distance_compare_t { };
        -:   31:  struct distance_combine_t { };
        -:   32:  struct distance_inf_t { };
        -:   33:  struct distance_zero_t { };
        -:   34:  struct buffer_param_t { };
        -:   35:  struct edge_copy_t { };
        -:   36:  struct vertex_copy_t { };
        -:   37:  struct vertex_isomorphism_t { };
        -:   38:  struct vertex_invariant_t { };
        -:   39:  struct vertex_invariant1_t { };
        -:   40:  struct vertex_invariant2_t { };
        -:   41:  struct edge_compare_t { };
        -:   42:  struct vertex_max_invariant_t { };
        -:   43:  struct orig_to_copy_t { };
        -:   44:  struct root_vertex_t { };
        -:   45:  struct polling_t { };
        -:   46:  struct lookahead_t { };
        -:   47:  struct in_parallel_t { };
        -:   48:  struct attractive_force_t { };
        -:   49:  struct repulsive_force_t { };
        -:   50:  struct force_pairs_t { };
        -:   51:  struct cooling_t { };
        -:   52:  struct vertex_displacement_t { };
        -:   53:  struct iterations_t { };
        -:   54:  struct diameter_range_t { };
        -:   55:  struct learning_constant_range_t { };
        -:   56:  struct vertices_equivalent_t { };
        -:   57:  struct edges_equivalent_t { };
        -:   58:  struct index_in_heap_map_t { };
        -:   59:  struct max_priority_queue_t { };
        -:   60:
        -:   61:#define BOOST_BGL_DECLARE_NAMED_PARAMS \
        -:   62:    BOOST_BGL_ONE_PARAM_CREF(weight_map, edge_weight) \
        -:   63:    BOOST_BGL_ONE_PARAM_CREF(weight_map2, edge_weight2) \
        -:   64:    BOOST_BGL_ONE_PARAM_CREF(distance_map, vertex_distance) \
        -:   65:    BOOST_BGL_ONE_PARAM_CREF(predecessor_map, vertex_predecessor) \
        -:   66:    BOOST_BGL_ONE_PARAM_CREF(rank_map, vertex_rank) \
        -:   67:    BOOST_BGL_ONE_PARAM_CREF(root_map, vertex_root) \
        -:   68:    BOOST_BGL_ONE_PARAM_CREF(root_vertex, root_vertex) \
        -:   69:    BOOST_BGL_ONE_PARAM_CREF(edge_centrality_map, edge_centrality) \
        -:   70:    BOOST_BGL_ONE_PARAM_CREF(centrality_map, vertex_centrality) \
        -:   71:    BOOST_BGL_ONE_PARAM_CREF(parity_map, parity_map) \
        -:   72:    BOOST_BGL_ONE_PARAM_CREF(color_map, vertex_color) \
        -:   73:    BOOST_BGL_ONE_PARAM_CREF(edge_color_map, edge_color) \
        -:   74:    BOOST_BGL_ONE_PARAM_CREF(capacity_map, edge_capacity) \
        -:   75:    BOOST_BGL_ONE_PARAM_CREF(residual_capacity_map, edge_residual_capacity) \
        -:   76:    BOOST_BGL_ONE_PARAM_CREF(reverse_edge_map, edge_reverse) \
        -:   77:    BOOST_BGL_ONE_PARAM_CREF(discover_time_map, vertex_discover_time) \
        -:   78:    BOOST_BGL_ONE_PARAM_CREF(lowpoint_map, vertex_lowpoint) \
        -:   79:    BOOST_BGL_ONE_PARAM_CREF(vertex_index_map, vertex_index) \
        -:   80:    BOOST_BGL_ONE_PARAM_CREF(vertex_index1_map, vertex_index1) \
        -:   81:    BOOST_BGL_ONE_PARAM_CREF(vertex_index2_map, vertex_index2) \
        -:   82:    BOOST_BGL_ONE_PARAM_CREF(vertex_assignment_map, vertex_assignment_map) \
        -:   83:    BOOST_BGL_ONE_PARAM_CREF(visitor, graph_visitor) \
        -:   84:    BOOST_BGL_ONE_PARAM_CREF(distance_compare, distance_compare) \
        -:   85:    BOOST_BGL_ONE_PARAM_CREF(distance_combine, distance_combine) \
        -:   86:    BOOST_BGL_ONE_PARAM_CREF(distance_inf, distance_inf) \
        -:   87:    BOOST_BGL_ONE_PARAM_CREF(distance_zero, distance_zero) \
        -:   88:    BOOST_BGL_ONE_PARAM_CREF(edge_copy, edge_copy) \
        -:   89:    BOOST_BGL_ONE_PARAM_CREF(vertex_copy, vertex_copy) \
        -:   90:    BOOST_BGL_ONE_PARAM_REF(buffer, buffer_param) \
        -:   91:    BOOST_BGL_ONE_PARAM_CREF(orig_to_copy, orig_to_copy) \
        -:   92:    BOOST_BGL_ONE_PARAM_CREF(isomorphism_map, vertex_isomorphism) \
        -:   93:    BOOST_BGL_ONE_PARAM_CREF(vertex_invariant, vertex_invariant) \
        -:   94:    BOOST_BGL_ONE_PARAM_CREF(vertex_invariant1, vertex_invariant1) \
        -:   95:    BOOST_BGL_ONE_PARAM_CREF(vertex_invariant2, vertex_invariant2) \
        -:   96:    BOOST_BGL_ONE_PARAM_CREF(vertex_max_invariant, vertex_max_invariant) \
        -:   97:    BOOST_BGL_ONE_PARAM_CREF(polling, polling) \
        -:   98:    BOOST_BGL_ONE_PARAM_CREF(lookahead, lookahead) \
        -:   99:    BOOST_BGL_ONE_PARAM_CREF(in_parallel, in_parallel) \
        -:  100:    BOOST_BGL_ONE_PARAM_CREF(displacement_map, vertex_displacement) \
        -:  101:    BOOST_BGL_ONE_PARAM_CREF(attractive_force, attractive_force) \
        -:  102:    BOOST_BGL_ONE_PARAM_CREF(repulsive_force, repulsive_force) \
        -:  103:    BOOST_BGL_ONE_PARAM_CREF(force_pairs, force_pairs) \
        -:  104:    BOOST_BGL_ONE_PARAM_CREF(cooling, cooling) \
        -:  105:    BOOST_BGL_ONE_PARAM_CREF(iterations, iterations) \
        -:  106:    BOOST_BGL_ONE_PARAM_CREF(diameter_range, diameter_range) \
        -:  107:    BOOST_BGL_ONE_PARAM_CREF(learning_constant_range, learning_constant_range) \
        -:  108:    BOOST_BGL_ONE_PARAM_CREF(vertices_equivalent, vertices_equivalent) \
        -:  109:    BOOST_BGL_ONE_PARAM_CREF(edges_equivalent, edges_equivalent) \
        -:  110:    BOOST_BGL_ONE_PARAM_CREF(index_in_heap_map, index_in_heap_map) \
        -:  111:    BOOST_BGL_ONE_PARAM_REF(max_priority_queue, max_priority_queue)
        -:  112:
        -:  113:  template <typename T, typename Tag, typename Base = no_property>
        -:  114:  struct bgl_named_params : public Base
        -:  115:  {
        -:  116:    typedef bgl_named_params self;
        -:  117:    typedef Base next_type;
        -:  118:    typedef Tag tag_type;
        -:  119:    typedef T value_type;
        -:  120:    bgl_named_params(T v = T()) : m_value(v) { }
        -:  121:    bgl_named_params(T v, const Base& b) : Base(b), m_value(v) { }
        -:  122:    T m_value;
        -:  123:
        -:  124:#define BOOST_BGL_ONE_PARAM_REF(name, key) \
        -:  125:    template <typename PType> \
        -:  126:    bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t), self> \
        -:  127:    name(PType& p) const { \
        -:  128:      typedef bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t), self> Params; \
        -:  129:      return Params(boost::ref(p), *this); \
        -:  130:    } \
        -:  131:
        -:  132:#define BOOST_BGL_ONE_PARAM_CREF(name, key) \
        -:  133:    template <typename PType> \
        -:  134:    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
        -:  135:    name(const PType& p) const { \
        -:  136:      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
        -:  137:      return Params(p, *this); \
        -:  138:    } \
        -:  139:
        -:  140:BOOST_BGL_DECLARE_NAMED_PARAMS
        -:  141:
        -:  142:#undef BOOST_BGL_ONE_PARAM_REF
        -:  143:#undef BOOST_BGL_ONE_PARAM_CREF
        -:  144:
        -:  145:    // Duplicate
        -:  146:    template <typename PType>
        -:  147:    bgl_named_params<PType, vertex_color_t, self>
        -:  148:    vertex_color_map(const PType& p) const {return this->color_map(p);}
        -:  149:  };
        -:  150:
        -:  151:#define BOOST_BGL_ONE_PARAM_REF(name, key) \
        -:  152:    template <typename PType> \
        -:  153:    bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t)> \
        -:  154:    name(PType& p) { \
        -:  155:      typedef bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t)> Params; \
        -:  156:      return Params(boost::ref(p)); \
        -:  157:    } \
        -:  158:
        -:  159:#define BOOST_BGL_ONE_PARAM_CREF(name, key) \
        -:  160:    template <typename PType> \
        -:  161:    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
        -:  162:    name(const PType& p) { \
        -:  163:      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
        -:  164:      return Params(p); \
        -:  165:    } \
        -:  166:
        -:  167:BOOST_BGL_DECLARE_NAMED_PARAMS
        -:  168:
        -:  169:#undef BOOST_BGL_ONE_PARAM_REF
        -:  170:#undef BOOST_BGL_ONE_PARAM_CREF
        -:  171:
        -:  172:  // Duplicate
        -:  173:  template <typename PType>
        -:  174:  bgl_named_params<PType, vertex_color_t>
        -:  175:  vertex_color_map(const PType& p) {return color_map(p);}
        -:  176:
        -:  177:  namespace detail {
        -:  178:    struct unused_tag_type {};
        -:  179:  }
        -:  180:  typedef bgl_named_params<char, detail::unused_tag_type> no_named_parameters;
        -:  181:
        -:  182:  //===========================================================================
        -:  183:  // Functions for extracting parameters from bgl_named_params
        -:  184:
        -:  185:  template <class Tag1, class Tag2, class T1, class Base>
        -:  186:  inline
        -:  187:  typename property_value< bgl_named_params<T1,Tag1,Base>, Tag2>::type
        -:  188:  get_param(const bgl_named_params<T1,Tag1,Base>& p, Tag2 tag2)
        -:  189:  {
        -:  190:    enum { match = detail::same_property<Tag1,Tag2>::value };
        -:  191:    typedef typename
        -:  192:      property_value< bgl_named_params<T1,Tag1,Base>, Tag2>::type T2;
        -:  193:    T2* t2 = 0;
        -:  194:    typedef detail::property_value_dispatch<match> Dispatcher;
        -:  195:    return Dispatcher::const_get_value(p, t2, tag2);
        -:  196:  }
        -:  197:
        -:  198:
        -:  199:  namespace detail {
        -:  200:    // MSVC++ workaround
        -:  201:    template <class Param>
        -:  202:    struct choose_param_helper {
        -:  203:      template <class Default> struct result { typedef Param type; };
        -:  204:      template <typename Default>
        -:  205:      static const Param& apply(const Param& p, const Default&) { return p; }
        -:  206:    };
        -:  207:    template <>
        -:  208:    struct choose_param_helper<error_property_not_found> {
        -:  209:      template <class Default> struct result { typedef Default type; };
        -:  210:      template <typename Default>
        -:  211:      static const Default& apply(const error_property_not_found&, const Default& d)
        -:  212:        { return d; }
        -:  213:    };
        -:  214:  } // namespace detail
        -:  215:
        -:  216:  template <class P, class Default> 
        -:  217:  const typename detail::choose_param_helper<P>::template result<Default>::type&
        -:  218:  choose_param(const P& param, const Default& d) { 
        -:  219:    return detail::choose_param_helper<P>::apply(param, d);
        -:  220:  }
        -:  221:
        -:  222:  template <typename T>
        -:  223:  inline bool is_default_param(const T&) { return false; }
        -:  224:
        -:  225:  inline bool is_default_param(const detail::error_property_not_found&)
        -:  226:    { return true; }
        -:  227:
        -:  228:  namespace detail {
        -:  229:
        -:  230:    struct choose_parameter {
        -:  231:      template <class P, class Graph, class Tag>
        -:  232:      struct bind_ {
        -:  233:        typedef const P& const_result_type;
        -:  234:        typedef const P& result_type;
        -:  235:        typedef P type;
        -:  236:      };
        -:  237:
        -:  238:      template <class P, class Graph, class Tag>
        -:  239:      static typename bind_<P, Graph, Tag>::const_result_type
        -:  240:      const_apply(const P& p, const Graph&, Tag&) 
        -:  241:      { return p; }
        -:  242:
        -:  243:      template <class P, class Graph, class Tag>
        -:  244:      static typename bind_<P, Graph, Tag>::result_type
        -:  245:      apply(const P& p, Graph&, Tag&) 
        -:  246:      { return p; }
        -:  247:    };
        -:  248:
        -:  249:    struct choose_default_param {
        -:  250:      template <class P, class Graph, class Tag>
        -:  251:      struct bind_ {
        -:  252:        typedef typename property_map<Graph, Tag>::type 
        -:  253:          result_type;
        -:  254:        typedef typename property_map<Graph, Tag>::const_type 
        -:  255:          const_result_type;
        -:  256:        typedef typename property_map<Graph, Tag>::const_type 
        -:  257:          type;
        -:  258:      };
        -:  259:
        -:  260:      template <class P, class Graph, class Tag>
        -:  261:      static typename bind_<P, Graph, Tag>::const_result_type
        -:  262:      const_apply(const P&, const Graph& g, Tag tag) { 
        -:  263:        return get(tag, g); 
        -:  264:      }
        -:  265:      template <class P, class Graph, class Tag>
        -:  266:      static typename bind_<P, Graph, Tag>::result_type
        -:  267:      apply(const P&, Graph& g, Tag tag) { 
        -:  268:        return get(tag, g); 
        -:  269:      }
        -:  270:    };
        -:  271:
        -:  272:    template <class Param>
        -:  273:    struct choose_property_map {
        -:  274:      typedef choose_parameter type;
        -:  275:    };
        -:  276:    template <>
        -:  277:    struct choose_property_map<detail::error_property_not_found> {
        -:  278:      typedef choose_default_param type;
        -:  279:    };
        -:  280:
        -:  281:    template <class Param, class Graph, class Tag>
        -:  282:    struct choose_pmap_helper {
        -:  283:      typedef typename choose_property_map<Param>::type Selector;
        -:  284:      typedef typename Selector:: template bind_<Param, Graph, Tag> Bind;
        -:  285:      typedef Bind type;
        -:  286:      typedef typename Bind::result_type result_type;
        -:  287:      typedef typename Bind::const_result_type const_result_type;
        -:  288:      typedef typename Bind::type result;
        -:  289:    };
        -:  290:
        -:  291:    // used in the max-flow algorithms
        -:  292:    template <class Graph, class P, class T, class R>
        -:  293:    struct edge_capacity_value
        -:  294:    {
        -:  295:      typedef bgl_named_params<P, T, R> Params;
        -:  296:      typedef typename property_value< Params, edge_capacity_t>::type Param;
        -:  297:      typedef typename detail::choose_pmap_helper<Param, Graph,
        -:  298:        edge_capacity_t>::result CapacityEdgeMap;
        -:  299:      typedef typename property_traits<CapacityEdgeMap>::value_type type;
        -:  300:    };
        -:  301:
        -:  302:  } // namespace detail
        -:  303:  
        -:  304:
        -:  305:  // Use this function instead of choose_param() when you want
        -:  306:  // to avoid requiring get(tag, g) when it is not used. 
        -:  307:  template <typename Param, typename Graph, typename PropertyTag>
        -:  308:  typename
        -:  309:    detail::choose_pmap_helper<Param,Graph,PropertyTag>::const_result_type
        -:  310:  choose_const_pmap(const Param& p, const Graph& g, PropertyTag tag)
        -:  311:  { 
        -:  312:    typedef typename 
        -:  313:      detail::choose_pmap_helper<Param,Graph,PropertyTag>::Selector Choice;
        -:  314:    return Choice::const_apply(p, g, tag);
        -:  315:  }
        -:  316:
        -:  317:  template <typename Param, typename Graph, typename PropertyTag>
        -:  318:  typename detail::choose_pmap_helper<Param,Graph,PropertyTag>::result_type
        -:  319:  choose_pmap(const Param& p, Graph& g, PropertyTag tag)
        -:  320:  { 
        -:  321:    typedef typename 
        -:  322:      detail::choose_pmap_helper<Param,Graph,PropertyTag>::Selector Choice;
        -:  323:    return Choice::apply(p, g, tag);
        -:  324:  }
        -:  325:
        -:  326:  // Declare all new tags
        -:  327:  namespace graph {
        -:  328:    namespace keywords {
        -:  329:#define BOOST_BGL_ONE_PARAM_REF(name, key) BOOST_PARAMETER_NAME(name)
        -:  330:#define BOOST_BGL_ONE_PARAM_CREF(name, key) BOOST_PARAMETER_NAME(name)
        -:  331:      BOOST_BGL_DECLARE_NAMED_PARAMS
        -:  332:#undef BOOST_BGL_ONE_PARAM_REF
        -:  333:#undef BOOST_BGL_ONE_PARAM_CREF
        -:  334:    }
        -:  335:  }
        -:  336:
        -:  337:  namespace detail {
        -:  338:    template <typename Tag> struct convert_one_keyword {};
        -:  339:#define BOOST_BGL_ONE_PARAM_REF(name, key) \
        -:  340:    template <> \
        -:  341:    struct convert_one_keyword<BOOST_PP_CAT(key, _t)> { \
        -:  342:      typedef boost::graph::keywords::tag::name type; \
        -:  343:    };
        -:  344:#define BOOST_BGL_ONE_PARAM_CREF(name, key) BOOST_BGL_ONE_PARAM_REF(name, key)
        -:  345:    BOOST_BGL_DECLARE_NAMED_PARAMS
        -:  346:#undef BOOST_BGL_ONE_PARAM_REF
        -:  347:#undef BOOST_BGL_ONE_PARAM_CREF
        -:  348:
        -:  349:    template <typename T>
        -:  350:    struct convert_bgl_params_to_boost_parameter {
        -:  351:      typedef typename convert_one_keyword<typename T::tag_type>::type new_kw;
        -:  352:      typedef boost::parameter::aux::tagged_argument<new_kw, const typename T::value_type> tagged_arg_type;
        -:  353:      typedef convert_bgl_params_to_boost_parameter<typename T::next_type> rest_conv;
        -:  354:      typedef boost::parameter::aux::arg_list<tagged_arg_type, typename rest_conv::type> type;
        -:  355:      static type conv(const T& x) {
        -:  356:        return type(tagged_arg_type(x.m_value), rest_conv::conv(x));
        -:  357:      }
        -:  358:    };
        -:  359:
        -:  360:    template <typename P, typename R>
        -:  361:    struct convert_bgl_params_to_boost_parameter<bgl_named_params<P, int, R> > {
        -:  362:      typedef convert_bgl_params_to_boost_parameter<R> rest_conv;
        -:  363:      typedef typename rest_conv::type type;
        -:  364:      static type conv(const bgl_named_params<P, int, R>& x) {
        -:  365:        return rest_conv::conv(x);
        -:  366:      }
        -:  367:    };
        -:  368:
        -:  369:    template <>
        -:  370:    struct convert_bgl_params_to_boost_parameter<boost::no_property> {
        -:  371:      typedef boost::parameter::aux::empty_arg_list type;
        -:  372:      static type conv(const boost::no_property&) {return type();}
        -:  373:    };
        -:  374:
        -:  375:    template <>
        -:  376:    struct convert_bgl_params_to_boost_parameter<boost::no_named_parameters> {
        -:  377:      typedef boost::parameter::aux::empty_arg_list type;
        -:  378:      static type conv(const boost::no_property&) {return type();}
        -:  379:    };
        -:  380:
        -:  381:    struct bgl_parameter_not_found_type {};
        -:  382:
        -:  383:    template <typename ArgPack, typename KeywordType>
        -:  384:    struct parameter_exists : boost::mpl::not_<boost::is_same<typename boost::parameter::binding<ArgPack, KeywordType, bgl_parameter_not_found_type>::type, bgl_parameter_not_found_type> > {};
        -:  385:  }
        -:  386:
        -:  387:#define BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(old_type, old_var) \
        -:  388:  typedef typename boost::detail::convert_bgl_params_to_boost_parameter<old_type>::type arg_pack_type; \
        -:  389:  arg_pack_type arg_pack = boost::detail::convert_bgl_params_to_boost_parameter<old_type>::conv(old_var);
        -:  390:
        -:  391:  namespace detail {
        -:  392:
        -:  393:    template <typename ArgType, typename Prop, typename Graph, bool Exists>
        -:  394:    struct override_const_property_t {
        -:  395:      typedef typename boost::remove_const<ArgType>::type result_type;
        -:  396:      result_type operator()(const Graph&, const ArgType& a) const {return a;}
        -:  397:    };
        -:  398:
        -:  399:    template <typename ArgType, typename Prop, typename Graph>
        -:  400:    struct override_const_property_t<ArgType, Prop, Graph, false> {
        -:  401:      typedef typename boost::property_map<Graph, Prop>::const_type result_type;
        -:  402:      result_type operator()(const Graph& g, const ArgType&) const {return get(Prop(), g);}
        -:  403:    };
        -:  404:
        -:  405:    template <typename ArgPack, typename Tag, typename Prop, typename Graph>
        -:  406:    struct override_const_property_result {
        -:  407:      typedef 
        -:  408:        typename override_const_property_t<
        -:  409:                   typename boost::parameter::value_type<ArgPack, Tag, int>::type,
        -:  410:                   Prop,
        -:  411:                   Graph,
        -:  412:                   boost::detail::parameter_exists<ArgPack, Tag>::value
        -:  413:                 >::result_type
        -:  414:        type;
        -:  415:    };
        -:  416:
        -:  417:    template <typename ArgPack, typename Tag, typename Prop, typename Graph>
        -:  418:    typename override_const_property_result<ArgPack, Tag, Prop, Graph>::type
        -:  419:    override_const_property(const ArgPack& ap, const boost::parameter::keyword<Tag>& t, const Graph& g, Prop) {
        -:  420:    return override_const_property_t<
        -:  421:             typename boost::parameter::value_type<ArgPack, Tag, int>::type,
        -:  422:             Prop,
        -:  423:             Graph,
        -:  424:             boost::detail::parameter_exists<ArgPack, Tag>::value
        -:  425:           >()(g, ap[t | 0]);
        -:  426:    }
        -:  427:
        -:  428:    template <typename ArgType, typename Prop, typename Graph, bool Exists>
        -:  429:    struct override_property_t {
        -:  430:      typedef ArgType result_type;
        -:  431:      result_type operator()(const Graph& g, const typename boost::add_reference<ArgType>::type a) const {return a;}
        -:  432:    };
        -:  433:
        -:  434:    template <typename ArgType, typename Prop, typename Graph>
        -:  435:    struct override_property_t<ArgType, Prop, Graph, false> {
        -:  436:      typedef typename boost::property_map<Graph, Prop>::type result_type;
        -:  437:      result_type operator()(const Graph& g, const ArgType& a) const {return get(Prop(), g);}
        -:  438:    };
        -:  439:
        -:  440:    template <typename ArgPack, typename Tag, typename Prop, typename Graph>
        -:  441:    struct override_property_result {
        -:  442:      typedef 
        -:  443:        typename override_property_t<
        -:  444:                   typename boost::parameter::value_type<ArgPack, Tag, int>::type,
        -:  445:                   Prop,
        -:  446:                   Graph,
        -:  447:                   boost::detail::parameter_exists<ArgPack, Tag>::value
        -:  448:                 >::result_type
        -:  449:        type;
        -:  450:    };
        -:  451:
        -:  452:    template <typename ArgPack, typename Tag, typename Prop, typename Graph>
        -:  453:    typename override_property_result<ArgPack, Tag, Prop, Graph>::type
        -:  454:    override_property(const ArgPack& ap, const boost::parameter::keyword<Tag>& t, const Graph& g, Prop prop) {
        -:  455:    return override_property_t<
        -:  456:             typename boost::parameter::value_type<ArgPack, Tag, int>::type,
        -:  457:             Prop,
        -:  458:             Graph,
        -:  459:             boost::detail::parameter_exists<ArgPack, Tag>::value
        -:  460:           >()(g, ap[t | 0]);
        -:  461:    }
        -:  462:
        -:  463:  }
        -:  464:
        -:  465:  namespace detail {
        -:  466:
        -:  467:    template <bool Exists, typename Graph, typename ArgPack, typename Value, typename PM>
        -:  468:    struct map_maker_helper {
        -:  469:      typedef PM map_type;
        -:  470:      static PM make_map(const Graph&, Value, const PM& pm, const ArgPack&) {
        -:  471:        return pm;
        -:  472:      }
        -:  473:    };
        -:  474:
        -:  475:    template <typename Graph, typename ArgPack, typename Value, typename PM>
        -:  476:    struct map_maker_helper<false, Graph, ArgPack, Value, PM> {
        -:  477:      typedef typename boost::remove_const<
        -:  478:        typename override_const_property_t<
        -:  479:          typename boost::parameter::value_type<
        -:  480:            ArgPack, boost::graph::keywords::tag::vertex_index_map, int>::type,
        -:  481:          boost::vertex_index_t,
        -:  482:          Graph,
        -:  483:          boost::detail::parameter_exists<
        -:  484:            ArgPack, boost::graph::keywords::tag::vertex_index_map>::value
        -:  485:        >::result_type>::type vi_map_type;
        -:  486:      typedef
        -:  487:        boost::shared_array_property_map<Value, vi_map_type>
        -:  488:        map_type;
        -:  489:      static map_type make_map(const Graph& g,
        -:  490:                               Value v,
        -:  491:                               const PM&,
        -:  492:                               const ArgPack& ap) {
        -:  493:        return make_shared_array_property_map(
        -:  494:                 num_vertices(g), 
        -:  495:                 v,
        -:  496:                 override_const_property(
        -:  497:                   ap,
        -:  498:                   boost::graph::keywords::_vertex_index_map,
        -:  499:                   g, vertex_index));
        -:  500:      }
        -:  501:    };
        -:  502:
        -:  503:    template <typename Graph, typename ArgPack, typename MapTag, typename ValueType>
        -:  504:    struct map_maker {
        -:  505:      BOOST_STATIC_CONSTANT(
        -:  506:        bool,
        -:  507:        has_map =
        -:  508:          (parameter_exists<ArgPack, MapTag>
        -:  509:           ::value));
        -:  510:      typedef map_maker_helper<has_map, Graph, ArgPack, ValueType,
        -:  511:                               typename boost::remove_const<
        -:  512:                                 typename boost::parameter::value_type<
        -:  513:                                            ArgPack,
        -:  514:                                            MapTag,
        -:  515:                                            int
        -:  516:                                          >::type
        -:  517:                                        >::type> helper;
        -:  518:      typedef typename helper::map_type map_type;
        -:  519:      static map_type make_map(const Graph& g, const ArgPack& ap, ValueType default_value) {
        -:  520:        return helper::make_map(g, default_value, ap[::boost::parameter::keyword<MapTag>::instance | 0], ap);
        -:  521:      }
        -:  522:    };
        -:  523:
        -:  524:    template <typename MapTag, typename ValueType = void>
        -:  525:    class make_property_map_from_arg_pack_gen {
        -:  526:      ValueType default_value;
        -:  527:
        -:  528:      public:
function _ZN5boost6detail35make_property_map_from_arg_pack_genINS_5graph8keywords3tag9color_mapENS_18default_color_typeEEC2ES6_ called 4 returned 100% blocks executed 100%
        4:  529:      make_property_map_from_arg_pack_gen(ValueType default_value)
        4:  530:        : default_value(default_value) {}
        -:  531:
        -:  532:      template <typename Graph, typename ArgPack>
        -:  533:      typename map_maker<Graph, ArgPack, MapTag, ValueType>::map_type
        -:  534:      operator()(const Graph& g, const ArgPack& ap) const {
        -:  535:        return map_maker<Graph, ArgPack, MapTag, ValueType>::make_map(g, ap, default_value);
        -:  536:      }
        -:  537:    };
        -:  538:
        -:  539:    template <typename MapTag>
        -:  540:    class make_property_map_from_arg_pack_gen<MapTag, void> {
        -:  541:      public:
        -:  542:      template <typename ValueType, typename Graph, typename ArgPack>
        -:  543:      typename map_maker<Graph, ArgPack, MapTag, ValueType>::map_type
        -:  544:      operator()(const Graph& g, const ArgPack& ap, ValueType default_value) const {
        -:  545:        return map_maker<Graph, ArgPack, MapTag, ValueType>::make_map(g, ap, default_value);
        -:  546:      }
        -:  547:    };
        -:  548:
        -:  549:    static const
        -:  550:      make_property_map_from_arg_pack_gen<
        -:  551:        boost::graph::keywords::tag::color_map,
        -:  552:        default_color_type>
        4:  553:      make_color_map_from_arg_pack(white_color);
call    0 returned 100%
        -:  554:
        -:  555:    template <bool Exists, class Graph, class ArgPack, class KeyT, class ValueT, class KeyMapTag, class IndexInHeapMapTag, class Compare, class Q>
        -:  556:    struct priority_queue_maker_helper {
        -:  557:      typedef Q priority_queue_type;
        -:  558:
        -:  559:      static priority_queue_type
        -:  560:      make_queue(const Graph& g, const ArgPack& ap, KeyT defaultKey, const Q& q) {
        -:  561:        return q;
        -:  562:      }
        -:  563:    };
        -:  564:
        -:  565:    template <class Graph, class ArgPack, class KeyT, class ValueT, class KeyMapTag, class IndexInHeapMapTag, class Compare, class Q>
        -:  566:    struct priority_queue_maker_helper<false, Graph, ArgPack, KeyT, ValueT, KeyMapTag, IndexInHeapMapTag, Compare, Q> {
        -:  567:      typedef typename std::vector<ValueT>::size_type default_index_in_heap_type;
        -:  568:      typedef typename map_maker<Graph, ArgPack, IndexInHeapMapTag, default_index_in_heap_type>::helper::map_type index_in_heap_map;
        -:  569:      typedef boost::d_ary_heap_indirect<ValueT, 4, index_in_heap_map, typename map_maker<Graph, ArgPack, KeyMapTag, KeyT>::helper::map_type, Compare> priority_queue_type;
        -:  570:
        -:  571:      static priority_queue_type
        -:  572:      make_queue(const Graph& g, const ArgPack& ap, KeyT defaultKey, const Q& q) {
        -:  573:        return priority_queue_type(
        -:  574:            map_maker<Graph, ArgPack, KeyMapTag, KeyT>::make_map(g, ap, defaultKey),
        -:  575:            map_maker<Graph, ArgPack, IndexInHeapMapTag, default_index_in_heap_type>::make_map(g, ap, typename boost::property_traits<index_in_heap_map>::value_type(-1))
        -:  576:          );
        -:  577:      }
        -:  578:    };
        -:  579:
        -:  580:    template <class Graph, class ArgPack, class KeyT, class ValueT, class PriorityQueueTag, class KeyMapTag, class IndexInHeapMapTag, class Compare>
        -:  581:    struct priority_queue_maker {
        -:  582:      BOOST_STATIC_CONSTANT(
        -:  583:        bool,
        -:  584:        g_hasQ =
        -:  585:          (parameter_exists<ArgPack, PriorityQueueTag>
        -:  586:           ::value));
        -:  587:      typedef boost::reference_wrapper<int> int_refw;
        -:  588:      typedef typename boost::parameter::value_type<
        -:  589:                         ArgPack,
        -:  590:                         PriorityQueueTag,
        -:  591:                         int_refw
        -:  592:                       >::type
        -:  593:        param_value_type_wrapper;
        -:  594:      typedef typename param_value_type_wrapper::type
        -:  595:        param_value_type;
        -:  596:      typedef typename boost::remove_const<param_value_type>::type param_value_type_no_const;
        -:  597:      typedef priority_queue_maker_helper<g_hasQ, Graph, ArgPack, KeyT, ValueT, KeyMapTag, IndexInHeapMapTag, Compare,
        -:  598:                                          param_value_type_no_const> helper;
        -:  599:      typedef typename helper::priority_queue_type priority_queue_type;
        -:  600:
        -:  601:      static priority_queue_type make_queue(const Graph& g, const ArgPack& ap, KeyT defaultKey) {
        -:  602:        return helper::make_queue(g, ap, defaultKey, ap[::boost::parameter::keyword<PriorityQueueTag>::instance | 0]);
        -:  603:      }
        -:  604:    };
        -:  605:
        -:  606:    template <class PriorityQueueTag, class KeyT, class ValueT, class Compare = std::less<KeyT>, class KeyMapTag = boost::graph::keywords::tag::distance_map, class IndexInHeapMapTag = boost::graph::keywords::tag::index_in_heap_map>
        -:  607:    struct make_priority_queue_from_arg_pack_gen {
        -:  608:      KeyT defaultKey;
        -:  609:
        -:  610:      make_priority_queue_from_arg_pack_gen(KeyT defaultKey_) : defaultKey(defaultKey_) { }
        -:  611:
        -:  612:      template <class Graph, class ArgPack>
        -:  613:      typename priority_queue_maker<Graph, ArgPack, KeyT, ValueT, PriorityQueueTag, KeyMapTag, IndexInHeapMapTag, Compare>::priority_queue_type
        -:  614:      operator()(const Graph& g, const ArgPack& ap) const {
        -:  615:        return priority_queue_maker<Graph, ArgPack, KeyT, ValueT, PriorityQueueTag, KeyMapTag, IndexInHeapMapTag, Compare>::make_queue(g, ap, defaultKey);
        -:  616:      }
        -:  617:    };
        -:  618:
        -:  619:  } // namespace detail
        -:  620:
        -:  621:} // namespace boost
        -:  622:
        -:  623:#undef BOOST_BGL_DECLARE_NAMED_PARAMS
        -:  624:
        -:  625:#endif // BOOST_GRAPH_NAMED_FUNCTION_PARAMS_HPP
